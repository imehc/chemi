import{e as L,g as B,a as $,b as _,c as tt,d as et,r as F,f as I,h as V,i as z,j as W,m as D,k as K,l as j,n as N,o as Q,s as nt}from"../../utils/dist/floating-ui.utils.mjs.GAwmRx9i.js";function q(e,n,r){let{reference:c,floating:o}=e;const t=V(n),a=K(n),A=Q(a),f=B(n),h=t==="y",d=c.x+c.width/2-o.width/2,s=c.y+c.height/2-o.height/2,l=c[A]/2-o[A]/2;let i;switch(f){case"top":i={x:d,y:c.y-o.height};break;case"bottom":i={x:d,y:c.y+c.height};break;case"right":i={x:c.x+c.width,y:s};break;case"left":i={x:c.x-o.width,y:s};break;default:i={x:c.x,y:c.y}}switch(W(n)){case"start":i[a]-=l*(r&&h?-1:1);break;case"end":i[a]+=l*(r&&h?-1:1);break}return i}const ct=async(e,n,r)=>{const{placement:c="bottom",strategy:o="absolute",middleware:t=[],platform:a}=r,A=t.filter(Boolean),f=await(a.isRTL==null?void 0:a.isRTL(n));let h=await a.getElementRects({reference:e,floating:n,strategy:o}),{x:d,y:s}=q(h,c,f),l=c,i={},m=0;for(let x=0;x<A.length;x++){const{name:u,fn:b}=A[x],{x:y,y:p,data:w,reset:g}=await b({x:d,y:s,initialPlacement:c,placement:l,strategy:o,middlewareData:i,rects:h,platform:a,elements:{reference:e,floating:n}});if(d=y??d,s=p??s,i={...i,[u]:{...i[u],...w}},g&&m<=50){m++,typeof g=="object"&&(g.placement&&(l=g.placement),g.rects&&(h=g.rects===!0?await a.getElementRects({reference:e,floating:n,strategy:o}):g.rects),{x:d,y:s}=q(h,l,f)),x=-1;continue}}return{x:d,y:s,placement:l,strategy:o,middlewareData:i}};async function Y(e,n){var r;n===void 0&&(n={});const{x:c,y:o,platform:t,rects:a,elements:A,strategy:f}=e,{boundary:h="clippingAncestors",rootBoundary:d="viewport",elementContext:s="floating",altBoundary:l=!1,padding:i=0}=L(n,e),m=I(i),u=A[l?s==="floating"?"reference":"floating":s],b=F(await t.getClippingRect({element:(r=await(t.isElement==null?void 0:t.isElement(u)))==null||r?u:u.contextElement||await(t.getDocumentElement==null?void 0:t.getDocumentElement(A.floating)),boundary:h,rootBoundary:d,strategy:f})),y=s==="floating"?{...a.floating,x:c,y:o}:a.reference,p=await(t.getOffsetParent==null?void 0:t.getOffsetParent(A.floating)),w=await(t.isElement==null?void 0:t.isElement(p))?await(t.getScale==null?void 0:t.getScale(p))||{x:1,y:1}:{x:1,y:1},g=F(t.convertOffsetParentRelativeRectToViewportRelativeRect?await t.convertOffsetParentRelativeRectToViewportRelativeRect({rect:y,offsetParent:p,strategy:f}):y);return{top:(b.top-g.top+m.top)/w.y,bottom:(g.bottom-b.bottom+m.bottom)/w.y,left:(b.left-g.left+m.left)/w.x,right:(g.right-b.right+m.right)/w.x}}const lt=e=>({name:"arrow",options:e,async fn(n){const{x:r,y:c,placement:o,rects:t,platform:a,elements:A}=n,{element:f,padding:h=0}=L(e,n)||{};if(f==null)return{};const d=I(h),s={x:r,y:c},l=K(o),i=Q(l),m=await a.getDimensions(f),x=l==="y",u=x?"top":"left",b=x?"bottom":"right",y=x?"clientHeight":"clientWidth",p=t.reference[i]+t.reference[l]-s[l]-t.floating[i],w=s[l]-t.reference[l],g=await(a.getOffsetParent==null?void 0:a.getOffsetParent(f));let v=g?g[y]:0;(!v||!await(a.isElement==null?void 0:a.isElement(g)))&&(v=A.floating[y]||t.floating[i]);const C=p/2-w/2,M=v/2-m[i]/2-1,T=j(d[u],M),O=j(d[b],M),P=T,H=v-m[i]-O,R=v/2-m[i]/2+C,k=z(P,R,H),E=W(o)!=null&&R!=k&&t.reference[i]/2-(R<P?T:O)-m[i]/2<0?R<P?P-R:H-R:0;return{[l]:s[l]-E,data:{[l]:k,centerOffset:R-k+E}}}}),at=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(n){var r;const{placement:c,middlewareData:o,rects:t,initialPlacement:a,platform:A,elements:f}=n,{mainAxis:h=!0,crossAxis:d=!0,fallbackPlacements:s,fallbackStrategy:l="bestFit",fallbackAxisSideDirection:i="none",flipAlignment:m=!0,...x}=L(e,n),u=B(c),b=B(a)===a,y=await(A.isRTL==null?void 0:A.isRTL(f.floating)),p=s||(b||!m?[$(a)]:_(a));!s&&i!=="none"&&p.push(...tt(a,m,i,y));const w=[a,...p],g=await Y(n,x),v=[];let C=((r=o.flip)==null?void 0:r.overflows)||[];if(h&&v.push(g[u]),d){const P=et(c,t,y);v.push(g[P[0]],g[P[1]])}if(C=[...C,{placement:c,overflows:v}],!v.every(P=>P<=0)){var M,T;const P=(((M=o.flip)==null?void 0:M.index)||0)+1,H=w[P];if(H)return{data:{index:P,overflows:C},reset:{placement:H}};let R=(T=C.filter(k=>k.overflows[0]<=0).sort((k,S)=>k.overflows[1]-S.overflows[1])[0])==null?void 0:T.placement;if(!R)switch(l){case"bestFit":{var O;const k=(O=C.map(S=>[S.placement,S.overflows.filter(E=>E>0).reduce((E,X)=>E+X,0)]).sort((S,E)=>S[1]-E[1])[0])==null?void 0:O[0];k&&(R=k);break}case"initialPlacement":R=a;break}if(c!==R)return{reset:{placement:R}}}return{}}}};function G(e,n){return{top:e.top-n.height,right:e.right-n.width,bottom:e.bottom-n.height,left:e.left-n.width}}function J(e){return nt.some(n=>e[n]>=0)}const rt=function(e){return e===void 0&&(e={}),{name:"hide",options:e,async fn(n){const{rects:r}=n,{strategy:c="referenceHidden",...o}=L(e,n);switch(c){case"referenceHidden":{const t=await Y(n,{...o,elementContext:"reference"}),a=G(t,r.reference);return{data:{referenceHiddenOffsets:a,referenceHidden:J(a)}}}case"escaped":{const t=await Y(n,{...o,altBoundary:!0}),a=G(t,r.floating);return{data:{escapedOffsets:a,escaped:J(a)}}}default:return{}}}}};function U(e){const n=j(...e.map(t=>t.left)),r=j(...e.map(t=>t.top)),c=D(...e.map(t=>t.right)),o=D(...e.map(t=>t.bottom));return{x:n,y:r,width:c-n,height:o-r}}function it(e){const n=e.slice().sort((o,t)=>o.y-t.y),r=[];let c=null;for(let o=0;o<n.length;o++){const t=n[o];!c||t.y-c.y>c.height/2?r.push([t]):r[r.length-1].push(t),c=t}return r.map(o=>F(U(o)))}const ft=function(e){return e===void 0&&(e={}),{name:"inline",options:e,async fn(n){const{placement:r,elements:c,rects:o,platform:t,strategy:a}=n,{padding:A=2,x:f,y:h}=L(e,n),d=Array.from(await(t.getClientRects==null?void 0:t.getClientRects(c.reference))||[]),s=it(d),l=F(U(d)),i=I(A);function m(){if(s.length===2&&s[0].left>s[1].right&&f!=null&&h!=null)return s.find(u=>f>u.left-i.left&&f<u.right+i.right&&h>u.top-i.top&&h<u.bottom+i.bottom)||l;if(s.length>=2){if(V(r)==="y"){const O=s[0],P=s[s.length-1],H=B(r)==="top",R=O.top,k=P.bottom,S=H?O.left:P.left,E=H?O.right:P.right,X=E-S,Z=k-R;return{top:R,bottom:k,left:S,right:E,width:X,height:Z,x:S,y:R}}const u=B(r)==="left",b=D(...s.map(O=>O.right)),y=j(...s.map(O=>O.left)),p=s.filter(O=>u?O.left===y:O.right===b),w=p[0].top,g=p[p.length-1].bottom,v=y,C=b,M=C-v,T=g-w;return{top:w,bottom:g,left:v,right:C,width:M,height:T,x:v,y:w}}return l}const x=await t.getElementRects({reference:{getBoundingClientRect:m},floating:c.floating,strategy:a});return o.reference.x!==x.reference.x||o.reference.y!==x.reference.y||o.reference.width!==x.reference.width||o.reference.height!==x.reference.height?{reset:{rects:x}}:{}}}};async function st(e,n){const{placement:r,platform:c,elements:o}=e,t=await(c.isRTL==null?void 0:c.isRTL(o.floating)),a=B(r),A=W(r),f=V(r)==="y",h=["left","top"].includes(a)?-1:1,d=t&&f?-1:1,s=L(n,e);let{mainAxis:l,crossAxis:i,alignmentAxis:m}=typeof s=="number"?{mainAxis:s,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...s};return A&&typeof m=="number"&&(i=A==="end"?m*-1:m),f?{x:i*d,y:l*h}:{x:l*h,y:i*d}}const mt=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(n){const{x:r,y:c}=n,o=await st(n,e);return{x:r+o.x,y:c+o.y,data:o}}}},dt=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(n){const{x:r,y:c,placement:o}=n,{mainAxis:t=!0,crossAxis:a=!1,limiter:A={fn:u=>{let{x:b,y}=u;return{x:b,y}}},...f}=L(e,n),h={x:r,y:c},d=await Y(n,f),s=V(B(o)),l=N(s);let i=h[l],m=h[s];if(t){const u=l==="y"?"top":"left",b=l==="y"?"bottom":"right",y=i+d[u],p=i-d[b];i=z(y,i,p)}if(a){const u=s==="y"?"top":"left",b=s==="y"?"bottom":"right",y=m+d[u],p=m-d[b];m=z(y,m,p)}const x=A.fn({...n,[l]:i,[s]:m});return{...x,data:{x:x.x-r,y:x.y-c}}}}},gt=function(e){return e===void 0&&(e={}),{options:e,fn(n){const{x:r,y:c,placement:o,rects:t,middlewareData:a}=n,{offset:A=0,mainAxis:f=!0,crossAxis:h=!0}=L(e,n),d={x:r,y:c},s=V(o),l=N(s);let i=d[l],m=d[s];const x=L(A,n),u=typeof x=="number"?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(f){const p=l==="y"?"height":"width",w=t.reference[l]-t.floating[p]+u.mainAxis,g=t.reference[l]+t.reference[p]-u.mainAxis;i<w?i=w:i>g&&(i=g)}if(h){var b,y;const p=l==="y"?"width":"height",w=["top","left"].includes(B(o)),g=t.reference[s]-t.floating[p]+(w&&((b=a.offset)==null?void 0:b[s])||0)+(w?0:u.crossAxis),v=t.reference[s]+t.reference[p]+(w?0:((y=a.offset)==null?void 0:y[s])||0)-(w?u.crossAxis:0);m<g?m=g:m>v&&(m=v)}return{[l]:i,[s]:m}}}},ut=function(e){return e===void 0&&(e={}),{name:"size",options:e,async fn(n){const{placement:r,rects:c,platform:o,elements:t}=n,{apply:a=()=>{},...A}=L(e,n),f=await Y(n,A),h=B(r),d=W(r),s=V(r)==="y",{width:l,height:i}=c.floating;let m,x;h==="top"||h==="bottom"?(m=h,x=d===(await(o.isRTL==null?void 0:o.isRTL(t.floating))?"start":"end")?"left":"right"):(x=h,m=d==="end"?"top":"bottom");const u=i-f[m],b=l-f[x],y=!n.middlewareData.shift;let p=u,w=b;if(s){const v=l-f.left-f.right;w=d||y?j(b,v):v}else{const v=i-f.top-f.bottom;p=d||y?j(u,v):v}if(y&&!d){const v=D(f.left,0),C=D(f.right,0),M=D(f.top,0),T=D(f.bottom,0);s?w=l-2*(v!==0||C!==0?v+C:D(f.left,f.right)):p=i-2*(M!==0||T!==0?M+T:D(f.top,f.bottom))}await a({...n,availableWidth:w,availableHeight:p});const g=await o.getDimensions(t.floating);return l!==g.width||i!==g.height?{reset:{rects:!0}}:{}}}};export{lt as a,ut as b,ct as c,at as f,rt as h,ft as i,gt as l,mt as o,dt as s};
//# sourceMappingURL=floating-ui.core.mjs.UGiqQufS.js.map
