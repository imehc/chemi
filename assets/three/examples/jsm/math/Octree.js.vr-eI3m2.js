import{V as c,G as I,aR as B,S as v,B as _,aS as A}from"../../../build/three.module.js.v3oJJcpo.js";import{C as O}from"./Capsule.js.quyXvW3N.js";const b=new c,m=new c,T=new c,p=new c,h=new I,w=new B,R=new B,y=new v,x=new O,V=new c,W=new c,q=new c,G=1e-10;function L(g,t,e=null,i=null){const n=V.copy(g.end).sub(g.start),s=W.copy(t.end).sub(t.start),o=q.copy(t.start).sub(g.start),r=n.dot(s),a=n.dot(n),l=s.dot(s),u=s.dot(o),M=n.dot(o);let d,f;const S=a*l-r*r;if(Math.abs(S)<G){const z=-u/l,P=(r-u)/l;Math.abs(z-.5)<Math.abs(P-.5)?(d=0,f=z):(d=1,f=P)}else d=(u*r+M*l)/S,f=(d*r-u)/l;f=Math.max(0,Math.min(1,f)),d=Math.max(0,Math.min(1,d)),e&&e.copy(n).multiplyScalar(d).add(g.start),i&&i.copy(s).multiplyScalar(f).add(t.start)}class C{constructor(t){this.triangles=[],this.box=t,this.subTrees=[]}addTriangle(t){return this.bounds||(this.bounds=new _),this.bounds.min.x=Math.min(this.bounds.min.x,t.a.x,t.b.x,t.c.x),this.bounds.min.y=Math.min(this.bounds.min.y,t.a.y,t.b.y,t.c.y),this.bounds.min.z=Math.min(this.bounds.min.z,t.a.z,t.b.z,t.c.z),this.bounds.max.x=Math.max(this.bounds.max.x,t.a.x,t.b.x,t.c.x),this.bounds.max.y=Math.max(this.bounds.max.y,t.a.y,t.b.y,t.c.y),this.bounds.max.z=Math.max(this.bounds.max.z,t.a.z,t.b.z,t.c.z),this.triangles.push(t),this}calcBox(){return this.box=this.bounds.clone(),this.box.min.x-=.01,this.box.min.y-=.01,this.box.min.z-=.01,this}split(t){if(!this.box)return;const e=[],i=m.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);for(let s=0;s<2;s++)for(let o=0;o<2;o++)for(let r=0;r<2;r++){const a=new _,l=b.set(s,o,r);a.min.copy(this.box.min).add(l.multiply(i)),a.max.copy(a.min).add(i),e.push(new C(a))}let n;for(;n=this.triangles.pop();)for(let s=0;s<e.length;s++)e[s].box.intersectsTriangle(n)&&e[s].triangles.push(n);for(let s=0;s<e.length;s++){const o=e[s].triangles.length;o>8&&t<16&&e[s].split(t+1),o!==0&&this.subTrees.push(e[s])}return this}build(){return this.calcBox(),this.split(0),this}getRayTriangles(t,e){for(let i=0;i<this.subTrees.length;i++){const n=this.subTrees[i];if(t.intersectsBox(n.box))if(n.triangles.length>0)for(let s=0;s<n.triangles.length;s++)e.indexOf(n.triangles[s])===-1&&e.push(n.triangles[s]);else n.getRayTriangles(t,e)}return e}triangleCapsuleIntersect(t,e){e.getPlane(h);const i=h.distanceToPoint(t.start)-t.radius,n=h.distanceToPoint(t.end)-t.radius;if(i>0&&n>0||i<-t.radius&&n<-t.radius)return!1;const s=Math.abs(i/(Math.abs(i)+Math.abs(n))),o=b.copy(t.start).lerp(t.end,s);if(e.containsPoint(o))return{normal:h.normal.clone(),point:o.clone(),depth:Math.abs(Math.min(i,n))};const r=t.radius*t.radius,a=w.set(t.start,t.end),l=[[e.a,e.b],[e.b,e.c],[e.c,e.a]];for(let u=0;u<l.length;u++){const M=R.set(l[u][0],l[u][1]);if(L(a,M,T,p),T.distanceToSquared(p)<r)return{normal:T.clone().sub(p).normalize(),point:p.clone(),depth:t.radius-T.distanceTo(p)}}return!1}triangleSphereIntersect(t,e){if(e.getPlane(h),!t.intersectsPlane(h))return!1;const i=Math.abs(h.distanceToSphere(t)),n=t.radius*t.radius-i*i,s=h.projectPoint(t.center,b);if(e.containsPoint(t.center))return{normal:h.normal.clone(),point:s.clone(),depth:Math.abs(h.distanceToSphere(t))};const o=[[e.a,e.b],[e.b,e.c],[e.c,e.a]];for(let r=0;r<o.length;r++){w.set(o[r][0],o[r][1]),w.closestPointToPoint(s,!0,m);const a=m.distanceToSquared(t.center);if(a<n)return{normal:t.center.clone().sub(m).normalize(),point:m.clone(),depth:t.radius-Math.sqrt(a)}}return!1}getSphereTriangles(t,e){for(let i=0;i<this.subTrees.length;i++){const n=this.subTrees[i];if(t.intersectsBox(n.box))if(n.triangles.length>0)for(let s=0;s<n.triangles.length;s++)e.indexOf(n.triangles[s])===-1&&e.push(n.triangles[s]);else n.getSphereTriangles(t,e)}}getCapsuleTriangles(t,e){for(let i=0;i<this.subTrees.length;i++){const n=this.subTrees[i];if(t.intersectsBox(n.box))if(n.triangles.length>0)for(let s=0;s<n.triangles.length;s++)e.indexOf(n.triangles[s])===-1&&e.push(n.triangles[s]);else n.getCapsuleTriangles(t,e)}}sphereIntersect(t){y.copy(t);const e=[];let i,n=!1;this.getSphereTriangles(t,e);for(let s=0;s<e.length;s++)(i=this.triangleSphereIntersect(y,e[s]))&&(n=!0,y.center.add(i.normal.multiplyScalar(i.depth)));if(n){const s=y.center.clone().sub(t.center),o=s.length();return{normal:s.normalize(),depth:o}}return!1}capsuleIntersect(t){x.copy(t);const e=[];let i,n=!1;this.getCapsuleTriangles(x,e);for(let s=0;s<e.length;s++)(i=this.triangleCapsuleIntersect(x,e[s]))&&(n=!0,x.translate(i.normal.multiplyScalar(i.depth)));if(n){const s=x.getCenter(new c).sub(t.getCenter(b)),o=s.length();return{normal:s.normalize(),depth:o}}return!1}rayIntersect(t){if(t.direction.length()===0)return;const e=[];let i,n,s=1e100;this.getRayTriangles(t,e);for(let o=0;o<e.length;o++){const r=t.intersectTriangle(e[o].a,e[o].b,e[o].c,!0,b);if(r){const a=r.sub(t.origin).length();s>a&&(n=r.clone().add(t.origin),s=a,i=e[o])}}return s<1e100?{distance:s,triangle:i,position:n}:!1}fromGraphNode(t){return t.updateWorldMatrix(!0,!0),t.traverse(e=>{if(e.isMesh===!0){let i,n=!1;e.geometry.index!==null?(n=!0,i=e.geometry.toNonIndexed()):i=e.geometry;const s=i.getAttribute("position");for(let o=0;o<s.count;o+=3){const r=new c().fromBufferAttribute(s,o),a=new c().fromBufferAttribute(s,o+1),l=new c().fromBufferAttribute(s,o+2);r.applyMatrix4(e.matrixWorld),a.applyMatrix4(e.matrixWorld),l.applyMatrix4(e.matrixWorld),this.addTriangle(new A(r,a,l))}n&&i.dispose()}}),this.build(),this}}export{C as O};
//# sourceMappingURL=Octree.js.vr-eI3m2.js.map
