{"version":3,"file":"DRACOLoader.js.PDTfz-VZ.js","sources":["../../../../node_modules/.pnpm/three-stdlib@2.28.7_three@0.158.0/node_modules/three-stdlib/loaders/DRACOLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport {\n  DRACOLoader\n};\n//# sourceMappingURL=DRACOLoader.js.map\n"],"names":["_taskCache","DRACOLoader","Loader","manager","path","config","workerLimit","url","onLoad","onProgress","onError","loader","FileLoader","buffer","taskConfig","callback","attributeIDs","attributeTypes","attribute","type","taskKey","cachedTask","worker","taskID","taskCost","geometryPending","_worker","resolve","reject","message","geometryData","geometry","BufferGeometry","BufferAttribute","name","array","itemSize","responseType","useJS","librariesPending","libraries","jsContent","fn","DRACOWorker","body","worker2","e","a","b","i","decoderConfig","decoderPending","draco","module","decoder","decoderBuffer","decodeGeometry","buffers","attr","error","dracoGeometry","decodingStatus","geometryType","attributeName","attributeType","attributeID","decodeAttribute","decodeIndex","numIndices","byteLength","ptr","index","numComponents","numValues","dataType","getDracoDataType"],"mappings":"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","x_google_ignoreList":[0]}