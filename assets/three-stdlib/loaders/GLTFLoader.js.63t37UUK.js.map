{"version":3,"file":"GLTFLoader.js.63t37UUK.js","sources":["../../../../node_modules/.pnpm/three-stdlib@2.28.7_three@0.158.0/node_modules/three-stdlib/loaders/GLTFLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, MeshPhysicalMaterial, Vector2, Matrix4, Vector3, Quaternion, InstancedMesh, Object3D, TextureLoader, ImageBitmapLoader, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, TriangleStripDrawMode, TriangleFanDrawMode, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, Skeleton, InterpolateLinear, AnimationClip, Bone, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Box3, Sphere, Interpolant } from \"three\";\nimport { toTrianglesDrawMode } from \"../utils/BufferGeometryUtils.js\";\nimport { version } from \"../_polyfill/constants.js\";\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse(LoaderUtils.decodeText(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(16777215);\n    if (lightDef.color !== void 0)\n      color.fromArray(lightDef.color);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, 3001));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, 3001)\n        // sRGBEncoding\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new Matrix4();\n        const p = new Vector3();\n        const q = new Quaternion();\n        const s = new Vector3(1, 1, 1);\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = new Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = new Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, encoding) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (encoding !== void 0) {\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n        else\n          texture.encoding = encoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, 3001));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        node.updateMatrix();\n        let TypedKeyframeTrack;\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function(object) {\n            if (object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n        let outputArray = outputAccessor.array;\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n          outputArray = scaled;\n        }\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(\n            targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n            inputAccessor.array,\n            outputArray,\n            interpolation\n          );\n          if (sampler.interpolation === \"CUBICSPLINE\") {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n            };\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n          tracks.push(track);\n        }\n      }\n      return new AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nexport {\n  GLTFLoader\n};\n//# sourceMappingURL=GLTFLoader.js.map\n"],"names":["GLTFLoader","Loader","manager","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","url","onLoad","onProgress","onError","scope","resourcePath","LoaderUtils","_onError","e","loader","FileLoader","data","gltf","dracoLoader","ktx2Loader","meshoptDecoder","callback","path","json","extensions","plugins","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","GLTFBinaryExtension","error","GLTFParser","i","plugin","extensionName","extensionsRequired","GLTFMaterialsUnlitExtension","GLTFDracoMeshCompressionExtension","GLTFTextureTransformExtension","GLTFMeshQuantizationExtension","resolve","reject","GLTFRegistry","objects","key","object","nodeDefs","nodeIndex","nodeLength","nodeDef","lightIndex","cacheKey","dependency","lightDef","lightNode","color","Color","range","DirectionalLight","PointLight","SpotLight","assignExtrasToUserData","type","index","self2","light","MeshBasicMaterial","materialParams","materialDef","pending","metallicRoughness","array","materialIndex","emissiveStrength","MeshPhysicalMaterial","extension","scale","Vector2","colorArray","textureIndex","textureDef","name","source","handler","isSupported","image","bufferView","extensionDef","buffer","decoder","res","byteOffset","byteLength","count","stride","res2","result","meshDef","primitive","WEBGL_CONSTANTS","attributesDef","attributes","accessor","results","nodeObject","meshes","instancedMeshes","mesh","m","Matrix4","Vector3","q","Quaternion","s","instancedMesh","InstancedMesh","attributeName","Object3D","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","headerView","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","accessorDef","componentType","WEBGL_COMPONENT_TYPES","geometry","attribute","normalized","texture","transform","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","values","valueSize","offset","i1","t0","t","t1","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","version","PATH_PROPERTIES","INTERPOLATION","InterpolateLinear","InterpolateDiscrete","ALPHA_MODES","createDefaultMaterial","cache","MeshStandardMaterial","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","gltfDef","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","hasMorphColor","il","target","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","accessors","morphPositions","morphNormals","morphColors","updateMorphTargets","targetNames","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","attributesKey","keys","getNormalizedComponentScale","constructor","getImageURIMimeType","uri","_identityMatrix","options","isSafari","isFirefox","firefoxVersion","TextureLoader","ImageBitmapLoader","ext","dependencies","skinDefs","meshDefs","skinIndex","skinLength","joints","ref","updateMappings","original","clone","mappings","child","func","defs","def","bufferIndex","bufferDef","bufferViewDef","accessorIndex","itemSize","TypedArray","BufferAttribute","pendingBufferViews","bufferViews","elementBytes","itemBytes","byteStride","bufferAttribute","ibSlice","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","sourceIndex","sourceDef","promise","sampler","URL","sourceURI","isObjectURL","blob","sourceURI2","imageBitmap","Texture","mapName","mapDef","encoding","gltfReference","material","useDerivativeTangents","useVertexColors","useFlatShading","pointsMaterial","PointsMaterial","Material","lineMaterial","LineBasicMaterial","cachedMaterial","materialType","materialExtensions","kmuExtension","DoubleSide","alphaMode","originalName","sanitizedName","PropertyBinding","primitives","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","materials","geometries","SkinnedMesh","Mesh","toTrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","group","Group","cameraIndex","camera","cameraDef","params","PerspectiveCamera","MathUtils","OrthographicCamera","skinDef","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channel","input","output","nodes","inputAccessors","outputAccessors","samplers","tracks","node","inputAccessor","outputAccessor","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","outputArray","scaled","j","jl","track","interpolantType","AnimationClip","o","nodePending","childPending","childrenDef","skeletonPending","children","skeleton","nodeName","meshPromise","Bone","matrix","sceneIndex","sceneDef","scene","nodeIds","reduceAssociations","reducedAssociations","value","node2","computeBounds","box","Box3","min","max","boxScale","maxDisplacement","vector","sphere","Sphere","assignAttributeAccessor","gltfAttributeName","accessor2"],"mappings":"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","x_google_ignoreList":[0]}