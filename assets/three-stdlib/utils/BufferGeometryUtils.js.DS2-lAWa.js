import{bl as j,be as S,bd as k,a8 as z}from"../../three/build/three.module.js.jQmR1wrA.js";function R(e,u){if(u===j)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(u===S||u===k){let n=e.getIndex();if(n===null){const t=[],l=e.getAttribute("position");if(l!==void 0){for(let p=0;p<l.count;p++)t.push(p);e.setIndex(t),n=e.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e}const f=n.count-2,o=[];if(n)if(u===S)for(let t=1;t<=f;t++)o.push(n.getX(0)),o.push(n.getX(t)),o.push(n.getX(t+1));else for(let t=0;t<f;t++)t%2===0?(o.push(n.getX(t)),o.push(n.getX(t+1)),o.push(n.getX(t+2))):(o.push(n.getX(t+2)),o.push(n.getX(t+1)),o.push(n.getX(t)));o.length/3!==f&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const d=e.clone();return d.setIndex(o),d.clearGroups(),d}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",u),e}function N(e,u=1e-4){u=Math.max(u,Number.EPSILON);const n={},f=e.getIndex(),o=e.getAttribute("position"),d=f?f.count:o.count;let t=0;const l=Object.keys(e.attributes),p={},m={},T=[],M=["getX","getY","getZ","getW"];for(let i=0,g=l.length;i<g;i++){const s=l[i];p[s]=[];const r=e.morphAttributes[s];r&&(m[s]=new Array(r.length).fill(0).map(()=>[]))}const D=Math.log10(1/u),G=Math.pow(10,D);for(let i=0;i<d;i++){const g=f?f.getX(i):i;let s="";for(let r=0,A=l.length;r<A;r++){const h=l[r],c=e.getAttribute(h),a=c.itemSize;for(let b=0;b<a;b++)s+=`${~~(c[M[b]](g)*G)},`}if(s in n)T.push(n[s]);else{for(let r=0,A=l.length;r<A;r++){const h=l[r],c=e.getAttribute(h),a=e.morphAttributes[h],b=c.itemSize,I=p[h],U=m[h];for(let X=0;X<b;X++){const E=M[X];if(I.push(c[E](g)),a)for(let x=0,B=a.length;x<B;x++)U[x].push(a[x][E](g))}}n[s]=t,T.push(t),t++}}const w=e.clone();for(let i=0,g=l.length;i<g;i++){const s=l[i],r=e.getAttribute(s),A=new r.array.constructor(p[s]),h=new z(A,r.itemSize,r.normalized);if(w.setAttribute(s,h),s in m)for(let c=0;c<m[s].length;c++){const a=e.morphAttributes[s][c],b=new a.array.constructor(m[s][c]),I=new z(b,a.itemSize,a.normalized);w.morphAttributes[s][c]=I}}return w.setIndex(T),w}export{N as m,R as t};
