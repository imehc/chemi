{"version":3,"file":"GroundProjectedEnv.js.VMS1s5Aq.js","sources":["../../../../node_modules/.pnpm/three-stdlib@2.28.7_three@0.158.0/node_modules/three-stdlib/objects/GroundProjectedEnv.js"],"sourcesContent":["import { Mesh, REVISION, IcosahedronGeometry, ShaderMaterial, DoubleSide } from \"three\";\nconst isCubeTexture = (def) => def && def.isCubeTexture;\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _a, _b;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [\n      isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n      `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n    ];\n    const vertexShader = (\n      /* glsl */\n      `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    );\n    const fragmentShader = defines.join(\"\\n\") + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n    const uniforms = {\n      map: { value: texture },\n      height: { value: (options == null ? void 0 : options.height) || 15 },\n      radius: { value: (options == null ? void 0 : options.radius) || 100 }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\nexport {\n  GroundProjectedEnv\n};\n//# sourceMappingURL=GroundProjectedEnv.js.map\n"],"names":["isCubeTexture","def","GroundProjectedEnv","Mesh","texture","options","_a","_b","isCubeMap","cubeSize","_lodMax","_cubeSize","width","height","defines","vertexShader","fragmentShader","REVISION","uniforms","geometry","IcosahedronGeometry","material","ShaderMaterial","DoubleSide","radius"],"mappings":"gGACA,MAAMA,EAAiBC,GAAQA,GAAOA,EAAI,cAC1C,MAAMC,UAA2BC,CAAK,CACpC,YAAYC,EAASC,EAAS,CAC5B,IAAIC,EAAIC,EACR,MAAMC,EAAYR,EAAcI,CAAO,EAEjCK,IADKF,EAAKC,GAAaF,EAAKF,EAAQ,MAAM,CAAC,IAAM,KAAO,OAASE,EAAG,MAAQF,EAAQ,MAAM,QAAU,KAAOG,EAAK,MACjG,EACfG,EAAU,KAAK,MAAM,KAAK,KAAKD,CAAQ,CAAC,EACxCE,EAAY,KAAK,IAAI,EAAGD,CAAO,EAC/BE,EAAQ,EAAI,KAAK,IAAID,EAAW,GAAK,CAAC,EACtCE,EAAS,EAAIF,EACbG,EAAU,CACdN,EAAY,2BAA6B,GACzC,8BAA8B,EAAII,CAAK,GACvC,+BAA+B,EAAIC,CAAM,GACzC,0BAA0BH,CAAO,IACvC,EACUK,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAWIC,EAAiBF,EAAQ,KAAK;AAAA,CAAI,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAqEoB,SAASG,EAAS,QAAQ,OAAQ,EAAE,CAAC,GAAK,IAAM,sBAAwB,oBAAoB;AAAA;AAAA,UAG1GC,EAAW,CACf,IAAK,CAAE,MAAOd,CAAS,EACvB,OAAQ,CAAE,OAAQC,GAAW,KAAO,OAASA,EAAQ,SAAW,EAAI,EACpE,OAAQ,CAAE,OAAQA,GAAW,KAAO,OAASA,EAAQ,SAAW,GAAK,CAC3E,EACUc,EAAW,IAAIC,EAAoB,EAAG,EAAE,EACxCC,EAAW,IAAIC,EAAe,CAClC,SAAAJ,EACA,eAAAF,EACA,aAAAD,EACA,KAAMQ,CACZ,CAAK,EACD,MAAMJ,EAAUE,CAAQ,CACzB,CACD,IAAI,OAAOG,EAAQ,CACjB,KAAK,SAAS,SAAS,OAAO,MAAQA,CACvC,CACD,IAAI,QAAS,CACX,OAAO,KAAK,SAAS,SAAS,OAAO,KACtC,CACD,IAAI,OAAOX,EAAQ,CACjB,KAAK,SAAS,SAAS,OAAO,MAAQA,CACvC,CACD,IAAI,QAAS,CACX,OAAO,KAAK,SAAS,SAAS,OAAO,KACtC,CACH","x_google_ignoreList":[0]}