import{_ as yt}from"../../drei/core/useVideoTexture.js.ClUDHY4w.js";import{Vector3 as We,EventQueue as vt,ColliderDesc as Ct,ActiveEvents as Ee,RigidBodyDesc as bt}from"../../../@dimforge/rapier3d-compat/rapier.es.js.DB2a0ird.js";import{r as l,R as c}from"../../../react/index.js.IuPGg7Py.js";import{a6 as Ne,V as q,s as Et,n as ht,a7 as xt,Q as ze,a8 as Qe,a9 as Rt}from"../../../three/build/three.module.js.jQmR1wrA.js";import{s as St}from"../../../suspend-react/index.js.BKIKQNXN.js";import{m as Pt}from"../../../three-stdlib/utils/BufferGeometryUtils.js.DS2-lAWa.js";import{u as wt,a as Ze}from"../../fiber/dist/index-ba8afaa4.esm.js.CC8UC62r.js";function Ft(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function Ue(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),o.push.apply(o,n)}return o}function m(e){for(var t=1;t<arguments.length;t++){var o=arguments[t]!=null?arguments[t]:{};t%2?Ue(Object(o),!0).forEach(function(n){Ft(e,n,o[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):Ue(Object(o)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))})}return e}const Mt=new ze;new Ne;const Ot=new q;new Et;const Q=new ht,F=new q,L=new ze,X=new q,jt=e=>{const[t,o,n]=e;return new q(t,o,n)},Ke=({x:e,y:t,z:o,w:n})=>Mt.set(e,t,o,n),ee=e=>{if(Array.isArray(e))return new We(e[0],e[1],e[2]);if(typeof e=="number")return new We(e,e,e);{const t=e;return new We(t.x,t.y,t.z)}},It={fixed:1,dynamic:0,kinematicPosition:2,kinematicVelocity:3},_e=e=>It[e],At=(e,t)=>{const o=Array.from(e);for(let n=0;n<e.length/3;n++)o[n*3]*=t.x,o[n*3+1]*=t.y,o[n*3+2]*=t.z;return o},$e=e=>e?e instanceof ze?[e.x,e.y,e.z,e.w]:e instanceof q||e instanceof Ne?[e.x,e.y,e.z]:Array.isArray(e)?e:[e]:[0];function J(e){const t=l.useRef();return t.current===void 0&&(t.current={value:typeof e=="function"?e():e}),t.current.value}const Bt=e=>{const t=l.useRef(e),o=l.useRef(0),n=l.useRef(0);l.useEffect(()=>{t.current=e},[e]),l.useEffect(()=>{const r=()=>{const i=performance.now(),a=i-n.current;o.current=requestAnimationFrame(r),t.current(a/1e3),n.current=i};return o.current=requestAnimationFrame(r),()=>cancelAnimationFrame(o.current)},[])},Dt=({onStep:e,updatePriority:t})=>(Ze((o,n)=>{e(n)},t),null),Tt=({onStep:e})=>(Bt(t=>{e(t)}),null),Wt=({onStep:e,type:t,updatePriority:o})=>t==="independent"?c.createElement(Tt,{onStep:e}):c.createElement(Dt,{onStep:e,updatePriority:o});var Nt=l.memo(Wt);function zt(e,t){if(e==null)return{};var o={},n=Object.keys(e),r,i;for(i=0;i<n.length;i++)r=n[i],!(t.indexOf(r)>=0)&&(o[r]=e[r]);return o}function Ve(e,t){if(e==null)return{};var o=zt(e,t),n,r;if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],!(t.indexOf(n)>=0)&&Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const Vt=["mass","linearDamping","angularDamping","type","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","onContactForce","children","canSleep","ccd","gravityScale"],qt=(e,t,o)=>{const n=t.slice();if(e==="heightfield"){const i=n[3];return i.x*=o.x,i.x*=o.y,i.x*=o.z,n}if(e==="trimesh"||e==="convexHull")return n[0]=At(n[0],o),n;const r=[o.x,o.y,o.z,o.x,o.x];return n.map((i,a)=>r[a]*i)},Lt=(e,t,o,n)=>{const r=qt(e.shape,e.args,o),i=Ct[e.shape](...r);return t.createCollider(i,n==null?void 0:n())},kt=["shape","args"],Ye="Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.",Ht=(e,t)=>{if(t.density!==void 0){if(t.mass!==void 0||t.massProperties!==void 0)throw new Error(Ye);e.setDensity(t.density);return}if(t.mass!==void 0){if(t.massProperties!==void 0)throw new Error(Ye);e.setMass(t.mass);return}t.massProperties!==void 0&&e.setMassProperties(t.massProperties.mass,t.massProperties.centerOfMass,t.massProperties.principalAngularInertia,t.massProperties.angularInertiaLocalFrame)},et={sensor:(e,t)=>{e.setSensor(t)},collisionGroups:(e,t)=>{e.setCollisionGroups(t)},solverGroups:(e,t)=>{e.setSolverGroups(t)},friction:(e,t)=>{e.setFriction(t)},frictionCombineRule:(e,t)=>{e.setFrictionCombineRule(t)},restitution:(e,t)=>{e.setRestitution(t)},restitutionCombineRule:(e,t)=>{e.setRestitutionCombineRule(t)},quaternion:()=>{},position:()=>{},rotation:()=>{},scale:()=>{}},tt=Object.keys(et),Gt=(e,t,o)=>{const n=o.get(e.handle);if(n){var r;const i=n.object.parent.getWorldScale(Ot),a=(r=n.worldParent)===null||r===void 0?void 0:r.matrixWorld.clone().invert();n.object.updateWorldMatrix(!0,!1),Q.copy(n.object.matrixWorld),a&&Q.premultiply(a),Q.decompose(F,L,X),e.parent()?(e.setTranslationWrtParent({x:F.x*i.x,y:F.y*i.y,z:F.z*i.z}),e.setRotationWrtParent(L)):(e.setTranslation({x:F.x*i.x,y:F.y*i.y,z:F.z*i.z}),e.setRotation(L)),tt.forEach(d=>{if(d in t){const g=t[d];et[d](e,g,t)}}),Ht(e,t)}},Jt=(e,t,o)=>{const n=l.useMemo(()=>tt.flatMap(r=>$e(t[r])),[t]);l.useEffect(()=>{const r=e();Gt(r,t,o)},[...n,e])},Qt=e=>{let t=!1;return e.traverseAncestors(o=>{o.userData.r3RapierType==="MeshCollider"&&(t=!0)}),t},Ut=(e,t,o)=>({collider:e,worldParent:o||void 0,object:t}),Kt={cuboid:"cuboid",ball:"ball",hull:"convexHull",trimesh:"trimesh"},Yt=({object:e,ignoreMeshColliders:t=!0,options:o})=>{const n=[];e.updateWorldMatrix(!0,!1);const r=e.matrixWorld.clone().invert(),i=a=>{if("isMesh"in a){if(t&&Qt(a))return;const d=a.getWorldScale(X),g=Kt[o.colliders||"cuboid"];a.updateWorldMatrix(!0,!1),Q.copy(a.matrixWorld).premultiply(r).decompose(F,L,X);const p=new Ne().setFromQuaternion(L,"XYZ"),{geometry:E}=a,{args:f,offset:h}=Xt(E,o.colliders||"cuboid"),R=m(m({},ot(o)),{},{args:f,shape:g,rotation:[p.x,p.y,p.z],position:[F.x+h.x*d.x,F.y+h.y*d.y,F.z+h.z*d.z],scale:[d.x,d.y,d.z]});n.push(R)}};return o.includeInvisible?e.traverse(i):e.traverseVisible(i),n},Xt=(e,t)=>{switch(t){case"cuboid":{e.computeBoundingBox();const{boundingBox:n}=e,r=n.getSize(new q);return{args:[r.x/2,r.y/2,r.z/2],offset:n.getCenter(new q)}}case"ball":{e.computeBoundingSphere();const{boundingSphere:n}=e;return{args:[n.radius],offset:n.center}}case"trimesh":{var o;const n=e.index?e.clone():Pt(e);return{args:[n.attributes.position.array,(o=n.index)===null||o===void 0?void 0:o.array],offset:new q}}case"hull":return{args:[e.clone().attributes.position.array],offset:new q}}return{args:[],offset:new q}},nt=e=>({collision:!!(e!=null&&e.onCollisionEnter||e!=null&&e.onCollisionExit||e!=null&&e.onIntersectionEnter||e!=null&&e.onIntersectionExit),contactForce:!!(e!=null&&e.onContactForce)}),Zt=(e,t,o,n={})=>{const{onCollisionEnter:r,onCollisionExit:i,onIntersectionEnter:a,onIntersectionExit:d,onContactForce:g}=t;l.useEffect(()=>{const p=e();if(p){const{collision:E,contactForce:f}=nt(t),h=E||n.collision,R=f||n.contactForce;h&&R?p.setActiveEvents(Ee.COLLISION_EVENTS|Ee.CONTACT_FORCE_EVENTS):h?p.setActiveEvents(Ee.COLLISION_EVENTS):R&&p.setActiveEvents(Ee.CONTACT_FORCE_EVENTS),o.set(p.handle,{onCollisionEnter:r,onCollisionExit:i,onIntersectionEnter:a,onIntersectionExit:d,onContactForce:g})}return()=>{p&&o.delete(p.handle)}},[r,i,a,d,g,n])},ot=(e={})=>Ve(e,Vt),Z=()=>{const e=l.useContext(rt);if(!e)throw new Error("react-three-rapier: useRapier must be used within <Physics />!");return e},qe=(e,t,o=!0)=>{const[n,r]=l.useState([]);return l.useEffect(()=>{e.current&&t.colliders!==!1&&r(Yt({object:e.current,options:t,ignoreMeshColliders:o}))},[t.colliders]),n},_t=l.memo(()=>{const{world:e}=Z(),t=l.useRef(null);return Ze(()=>{const o=t.current;if(!o)return;const n=e.debugRender();o.geometry.setAttribute("position",new Qe(n.vertices,3)),o.geometry.setAttribute("color",new Qe(n.colors,4))}),c.createElement("group",null,c.createElement("lineSegments",{ref:t,frustumCulled:!1},c.createElement("lineBasicMaterial",{color:16777215,vertexColors:!0}),c.createElement("bufferGeometry",null)))}),$t=e=>{let t;const o={get(a,d){return t||(t=e()),Reflect.get(t,d)},set(a,d,g){return t||(t=e()),Reflect.set(t,d,g)}};return{proxy:new Proxy({},o),reset:()=>{t=void 0},set:a=>{t=a}}},rt=l.createContext(void 0),he=(e,t)=>{var o,n,r,i,a,d;return{target:{rigidBody:e.rigidBody.object,collider:e.collider.object,colliderObject:(o=e.collider.state)===null||o===void 0?void 0:o.object,rigidBodyObject:(n=e.rigidBody.state)===null||n===void 0?void 0:n.object},other:{rigidBody:t.rigidBody.object,collider:t.collider.object,colliderObject:(r=t.collider.state)===null||r===void 0?void 0:r.object,rigidBodyObject:(i=t.rigidBody.state)===null||i===void 0?void 0:i.object},rigidBody:t.rigidBody.object,collider:t.collider.object,colliderObject:(a=t.collider.state)===null||a===void 0?void 0:a.object,rigidBodyObject:(d=t.rigidBody.state)===null||d===void 0?void 0:d.object}},Xe=async()=>{let e=await yt(()=>import("../../../@dimforge/rapier3d-compat/rapier.es.js.DB2a0ird.js"),[]);return await e.init(),e},Mn=e=>{const{colliders:t="cuboid",children:o,timeStep:n=1/60,paused:r=!1,interpolate:i=!0,updatePriority:a,updateLoop:d="follow",debug:g=!1,gravity:p=[0,-9.81,0],allowedLinearError:E=.001,predictionDistance:f=.002,numSolverIterations:h=4,numAdditionalFrictionIterations:R=4,numInternalPgsIterations:k=1,minIslandSize:W=128,maxCcdSubsteps:y=1,erp:v=.8}=e,b=St(Xe,["@react-thee/rapier",Xe]),{invalidate:S}=wt(),$=J(()=>new Map),P=J(()=>new Map),D=J(()=>new Map),He=J(()=>new Map),xe=J(()=>new vt(!1)),Ge=J(()=>new Set),Je=J(()=>new Set),{proxy:M,reset:ft,set:mt}=J(()=>$t(()=>new b.World(jt(p))));l.useEffect(()=>()=>{M.free(),ft()},[]),l.useEffect(()=>{M.gravity=ee(p),M.integrationParameters.numSolverIterations=h,M.integrationParameters.numAdditionalFrictionIterations=R,M.integrationParameters.numInternalPgsIterations=k,M.integrationParameters.allowedLinearError=E,M.integrationParameters.minIslandSize=W,M.integrationParameters.maxCcdSubsteps=y,M.integrationParameters.predictionDistance=f,M.integrationParameters.erp=v},[M,...p,h,R,k,E,W,y,f,v]);const te=l.useCallback(H=>{var A;const K=M.getCollider(H),oe=He.get(H),re=P.get(H),G=K==null||(A=K.parent())===null||A===void 0?void 0:A.handle,s=G!==void 0?M.getRigidBody(G):void 0,O=s&&G!==void 0?D.get(G):void 0,j=G!==void 0?$.get(G):void 0;return{collider:{object:K,events:oe,state:re},rigidBody:{object:s,events:O,state:j}}},[]),[U]=l.useState({previousState:{},accumulator:0}),ne=l.useCallback(H=>{const A=M,K=n==="vary",oe=Rt.clamp(H,0,.5),re=s=>{Ge.forEach(O=>{O.current(A)}),A.timestep=s,A.step(xe),Je.forEach(O=>{O.current(A)})};if(K)re(oe);else for(U.accumulator+=oe;U.accumulator>=n;)i&&(U.previousState={},A.forEachRigidBody(s=>{U.previousState[s.handle]={position:s.translation(),rotation:s.rotation()}})),re(n),U.accumulator-=n;const G=K||!i||r?1:U.accumulator/n;$.forEach((s,O)=>{const j=A.getRigidBody(O),u=D.get(O);if(u!=null&&u.onSleep||u!=null&&u.onWake){if(j.isSleeping()&&!s.isSleeping){var C;u==null||(C=u.onSleep)===null||C===void 0||C.call(u)}if(!j.isSleeping()&&s.isSleeping){var w;u==null||(w=u.onWake)===null||w===void 0||w.call(u)}s.isSleeping=j.isSleeping()}if(!j||j.isSleeping()&&!("isInstancedMesh"in s.object)||!s.setMatrix)return;let I=j.translation(),N=j.rotation(),z=U.previousState[O];z&&(Q.compose(z.position,Ke(z.rotation),s.scale).premultiply(s.invertedWorldMatrix).decompose(F,L,X),s.meshType=="mesh"&&(s.object.position.copy(F),s.object.quaternion.copy(L))),Q.compose(I,Ke(N),s.scale).premultiply(s.invertedWorldMatrix).decompose(F,L,X),s.meshType=="instancedMesh"?s.setMatrix(Q):(s.object.position.lerp(F,G),s.object.quaternion.slerp(L,G))}),xe.drainCollisionEvents((s,O,j)=>{const u=te(s),C=te(O);if(!(u!=null&&u.collider.object)||!(C!=null&&C.collider.object))return;const w=he(u,C),I=he(C,u);if(j)A.contactPair(u.collider.object,C.collider.object,(pe,ge)=>{var ye,Ae,ve,Be,Ce,De,be,Te;(ye=u.rigidBody.events)===null||ye===void 0||(Ae=ye.onCollisionEnter)===null||Ae===void 0||Ae.call(ye,m(m({},w),{},{manifold:pe,flipped:ge})),(ve=C.rigidBody.events)===null||ve===void 0||(Be=ve.onCollisionEnter)===null||Be===void 0||Be.call(ve,m(m({},I),{},{manifold:pe,flipped:ge})),(Ce=u.collider.events)===null||Ce===void 0||(De=Ce.onCollisionEnter)===null||De===void 0||De.call(Ce,m(m({},w),{},{manifold:pe,flipped:ge})),(be=C.collider.events)===null||be===void 0||(Te=be.onCollisionEnter)===null||Te===void 0||Te.call(be,m(m({},I),{},{manifold:pe,flipped:ge}))});else{var N,z,T,V,Y,_,ie,Re;(N=u.rigidBody.events)===null||N===void 0||(z=N.onCollisionExit)===null||z===void 0||z.call(N,w),(T=C.rigidBody.events)===null||T===void 0||(V=T.onCollisionExit)===null||V===void 0||V.call(T,I),(Y=u.collider.events)===null||Y===void 0||(_=Y.onCollisionExit)===null||_===void 0||_.call(Y,w),(ie=C.collider.events)===null||ie===void 0||(Re=ie.onCollisionExit)===null||Re===void 0||Re.call(ie,I)}if(j){if(A.intersectionPair(u.collider.object,C.collider.object)){var le,Se,se,Pe,ae,we,ce,Fe;(le=u.rigidBody.events)===null||le===void 0||(Se=le.onIntersectionEnter)===null||Se===void 0||Se.call(le,w),(se=C.rigidBody.events)===null||se===void 0||(Pe=se.onIntersectionEnter)===null||Pe===void 0||Pe.call(se,I),(ae=u.collider.events)===null||ae===void 0||(we=ae.onIntersectionEnter)===null||we===void 0||we.call(ae,w),(ce=C.collider.events)===null||ce===void 0||(Fe=ce.onIntersectionEnter)===null||Fe===void 0||Fe.call(ce,I)}}else{var de,Me,ue,Oe,fe,je,me,Ie;(de=u.rigidBody.events)===null||de===void 0||(Me=de.onIntersectionExit)===null||Me===void 0||Me.call(de,w),(ue=C.rigidBody.events)===null||ue===void 0||(Oe=ue.onIntersectionExit)===null||Oe===void 0||Oe.call(ue,I),(fe=u.collider.events)===null||fe===void 0||(je=fe.onIntersectionExit)===null||je===void 0||je.call(fe,w),(me=C.collider.events)===null||me===void 0||(Ie=me.onIntersectionExit)===null||Ie===void 0||Ie.call(me,I)}}),xe.drainContactForceEvents(s=>{var O,j,u,C,w,I,N,z;const T=te(s.collider1()),V=te(s.collider2());if(!(T!=null&&T.collider.object)||!(V!=null&&V.collider.object))return;const Y=he(T,V),_=he(V,T);(O=T.rigidBody.events)===null||O===void 0||(j=O.onContactForce)===null||j===void 0||j.call(O,m(m({},Y),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()})),(u=V.rigidBody.events)===null||u===void 0||(C=u.onContactForce)===null||C===void 0||C.call(u,m(m({},_),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()})),(w=T.collider.events)===null||w===void 0||(I=w.onContactForce)===null||I===void 0||I.call(w,m(m({},Y),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()})),(N=V.collider.events)===null||N===void 0||(z=N.onContactForce)===null||z===void 0||z.call(N,m(m({},_),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()}))}),A.forEachActiveRigidBody(()=>{S()})},[r,n,i,M]),pt=l.useMemo(()=>({rapier:b,world:M,setWorld:H=>{mt(H)},physicsOptions:{colliders:t,gravity:p},rigidBodyStates:$,colliderStates:P,rigidBodyEvents:D,colliderEvents:He,beforeStepCallbacks:Ge,afterStepCallbacks:Je,isPaused:r,isDebug:g,step:ne}),[r,ne,g,t,p]),gt=l.useCallback(H=>{r||ne(H)},[r,ne]);return c.createElement(rt.Provider,{value:pt},c.createElement(Nt,{onStep:gt,type:d,updatePriority:a}),g&&c.createElement(_t,null),o)};function x(){return x=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e},x.apply(this,arguments)}const Le=(e,t,o)=>{const n=l.useRef(),r=l.useCallback(()=>(n.current||(n.current=e()),n.current),o);return l.useEffect(()=>{const i=r(),a=()=>t(i);return()=>{a(),n.current=void 0}},[r]),r},en=({x:e,y:t,z:o}={x:0,y:0,z:0})=>new q(e,t,o),ke=(e,t=null)=>{const o=l.useRef(t);return e&&typeof e!="function"?(e.current||(e.current=o.current),e):o},B=l.memo(l.forwardRef((e,t)=>{const{children:o,position:n,rotation:r,quaternion:i,scale:a,name:d}=e,{world:g,colliderEvents:p,colliderStates:E}=Z(),f=ct(),h=ke(t),R=l.useRef(null),k=kt.flatMap(v=>Array.isArray(e[v])?[...e[v]]:e[v]),W=Le(()=>{const v=R.current.getWorldScale(en()),b=Lt(e,g,v,f==null?void 0:f.getRigidBody);return typeof t=="function"&&t(b),h.current=b,b},v=>{g.getCollider(v.handle)&&g.removeCollider(v,!0)},[...k,f]);l.useEffect(()=>{const v=W();return E.set(v.handle,Ut(v,R.current,f==null?void 0:f.ref.current)),()=>{E.delete(v.handle)}},[W]);const y=l.useMemo(()=>m(m({},ot(f==null?void 0:f.options)),e),[e,f==null?void 0:f.options]);return Jt(W,y,E),Zt(W,y,p,nt(f==null?void 0:f.options)),c.createElement("object3D",{position:n,rotation:r,quaternion:i,scale:a,ref:R,name:d},o)})),tn=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"cuboid",ref:t})));tn.displayName="CuboidCollider";const nn=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"roundCuboid",ref:t})));nn.displayName="RoundCuboidCollider";const on=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"ball",ref:t})));on.displayName="BallCollider";const rn=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"capsule",ref:t})));rn.displayName="CapsuleCollider";const ln=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"heightfield",ref:t})));ln.displayName="HeightfieldCollider";const sn=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"trimesh",ref:t})));sn.displayName="TrimeshCollider";const an=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"cone",ref:t})));an.displayName="ConeCollider";const cn=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"roundCone",ref:t})));cn.displayName="RoundConeCollider";const it=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"cylinder",ref:t})));it.displayName="CylinderCollider";it.displayName="RoundCylinderCollider";const dn=c.forwardRef((e,t)=>c.createElement(B,x({},e,{shape:"convexHull",ref:t})));dn.displayName="ConvexHullCollider";const un=e=>{var t;const o=_e((e==null?void 0:e.type)||"dynamic"),n=new bt(o);return n.canSleep=(t=e==null?void 0:e.canSleep)!==null&&t!==void 0?t:!0,n},fn=({rigidBody:e,object:t,setMatrix:o,getMatrix:n,worldScale:r,meshType:i="mesh"})=>{t.updateWorldMatrix(!0,!1);const a=t.parent.matrixWorld.clone().invert();return{object:t,rigidBody:e,invertedWorldMatrix:a,setMatrix:o||(d=>{t.matrix.copy(d)}),getMatrix:n||(d=>d.copy(t.matrix)),scale:r||t.getWorldScale(X).clone(),isSleeping:!1,meshType:i}},mn=["args","colliders","canSleep"],lt={gravityScale:(e,t)=>{e.setGravityScale(t,!0)},additionalSolverIterations(e,t){e.setAdditionalSolverIterations(t)},linearDamping:(e,t)=>{e.setLinearDamping(t)},angularDamping:(e,t)=>{e.setAngularDamping(t)},dominanceGroup:(e,t)=>{e.setDominanceGroup(t)},enabledRotations:(e,[t,o,n])=>{e.setEnabledRotations(t,o,n,!0)},enabledTranslations:(e,[t,o,n])=>{e.setEnabledTranslations(t,o,n,!0)},lockRotations:(e,t)=>{e.lockRotations(t,!0)},lockTranslations:(e,t)=>{e.lockTranslations(t,!0)},angularVelocity:(e,[t,o,n])=>{e.setAngvel({x:t,y:o,z:n},!0)},linearVelocity:(e,[t,o,n])=>{e.setLinvel({x:t,y:o,z:n},!0)},ccd:(e,t)=>{e.enableCcd(t)},userData:(e,t)=>{e.userData=t},type(e,t){e.setBodyType(_e(t),!0)},position:()=>{},rotation:()=>{},quaternion:()=>{},scale:()=>{}},st=Object.keys(lt),pn=(e,t,o,n=!0)=>{if(!e)return;const r=o.get(e.handle);r&&(n&&(r.object.updateWorldMatrix(!0,!1),Q.copy(r.object.matrixWorld).decompose(F,L,X),e.setTranslation(F,!1),e.setRotation(L,!1)),st.forEach(i=>{i in t&&lt[i](e,t[i])}))},gn=(e,t,o,n=!0)=>{const r=l.useMemo(()=>st.flatMap(i=>$e(t[i])),[t]);l.useEffect(()=>{const i=e();pn(i,t,o,n)},r)},yn=(e,t,o)=>{const{onWake:n,onSleep:r,onCollisionEnter:i,onCollisionExit:a,onIntersectionEnter:d,onIntersectionExit:g,onContactForce:p}=t,E={onWake:n,onSleep:r,onCollisionEnter:i,onCollisionExit:a,onIntersectionEnter:d,onIntersectionExit:g,onContactForce:p};l.useEffect(()=>{const f=e();return o.set(f.handle,E),()=>{o.delete(f.handle)}},[n,r,i,a,d,g,p])},vn=["children","type","position","rotation","scale","quaternion","transformState"],at=l.createContext(void 0),ct=()=>l.useContext(at),dt=l.memo(l.forwardRef((e,t)=>{const{children:o,type:n,position:r,rotation:i,scale:a,quaternion:d,transformState:g}=e,p=Ve(e,vn),E=l.useRef(null),f=ke(t),{world:h,rigidBodyStates:R,physicsOptions:k,rigidBodyEvents:W}=Z(),y=l.useMemo(()=>m(m(m({},k),e),{},{children:void 0}),[k,e]),v=mn.flatMap(P=>Array.isArray(y[P])?[...y[P]]:y[P]),b=qe(E,y),S=Le(()=>{const P=un(y),D=h.createRigidBody(P);return typeof t=="function"&&t(D),f.current=D,D},P=>{h.getRigidBody(P.handle)&&h.removeRigidBody(P)},v);l.useEffect(()=>{const P=S(),D=fn({rigidBody:P,object:E.current});return R.set(P.handle,e.transformState?e.transformState(D):D),()=>{R.delete(P.handle)}},[S]),gn(S,y,R),yn(S,y,W);const $=l.useMemo(()=>({ref:E,getRigidBody:S,options:y}),[S]);return c.createElement(at.Provider,{value:$},c.createElement("object3D",x({ref:E},p,{position:r,rotation:i,quaternion:d,scale:a}),o,b.map((P,D)=>c.createElement(B,x({key:D},P)))))}));dt.displayName="RigidBody";const Cn=l.memo(e=>{const{children:t,type:o}=e,{physicsOptions:n}=Z(),r=l.useRef(null),{options:i}=ct(),a=l.useMemo(()=>m(m(m({},n),i),{},{children:void 0,colliders:o}),[n,i]),d=qe(r,a,!1);return c.createElement("object3D",{ref:r,userData:{r3RapierType:"MeshCollider"}},t,d.map((g,p)=>c.createElement(B,x({key:p},g))))});Cn.displayName="MeshCollider";const bn=["children","instances","colliderNodes","position","rotation","quaternion","scale"],En=l.memo(l.forwardRef((e,t)=>{const o=ke(t,[]),n=l.useRef(null),r=l.useRef(null),{children:i,instances:a,colliderNodes:d=[],position:g,rotation:p,quaternion:E,scale:f}=e,h=Ve(e,bn),R=qe(n,m(m({},e),{},{children:void 0})),k=()=>{const y=r.current.children[0];if(y&&"isInstancedMesh"in y)return y};l.useEffect(()=>{const y=k();y?y.instanceMatrix.setUsage(xt):console.warn("InstancedRigidBodies expects exactly one child, which must be an InstancedMesh")},[]);const W=(y,v)=>{const b=k();return b?m(m({},y),{},{getMatrix:S=>(b.getMatrixAt(v,S),S),setMatrix:S=>{b.setMatrixAt(v,S),b.instanceMatrix.needsUpdate=!0},meshType:"instancedMesh"}):y};return c.createElement("object3D",x({ref:n},h,{position:g,rotation:p,quaternion:E,scale:f}),c.createElement("object3D",{ref:r},i),a==null?void 0:a.map((y,v)=>c.createElement(dt,x({},h,y,{ref:b=>o.current[v]=b,transformState:b=>W(b,v)}),c.createElement(c.Fragment,null,d.map((b,S)=>c.createElement(l.Fragment,{key:S},b)),R.map((b,S)=>c.createElement(B,x({key:S},b)))))))}));En.displayName="InstancedRigidBodies";const ut=(e,t,o)=>{const{world:n}=Z(),r=l.useRef();return Le(()=>{if(e.current&&t.current){const i=n.createImpulseJoint(o,e.current,t.current,!0);return r.current=i,i}},i=>{i&&(r.current=void 0,n.getImpulseJoint(i.handle)&&n.removeImpulseJoint(i,!0))},[]),r},On=(e,t,[o,n])=>{const{rapier:r}=Z();return ut(e,t,r.JointData.spherical(ee(o),ee(n)))},jn=(e,t,[o,n,r])=>{const{rapier:i}=Z(),a=ee(o),d=ee(n),g=i.JointData.rope(r,a,d);return ut(e,t,g)};export{on as B,tn as C,Mn as P,dt as R,On as a,jn as u};
