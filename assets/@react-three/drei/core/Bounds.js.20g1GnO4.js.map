{"version":3,"file":"Bounds.js.20g1GnO4.js","sources":["../../../../../node_modules/.pnpm/@react-three+drei@9.88.17_@react-three+fiber@8.15.11_@types+three@0.158.3_react-dom@18.2.0_react@18.2.0_three@0.158.0/node_modules/@react-three/drei/core/Bounds.js"],"sourcesContent":["import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nconst isOrthographic = def => def && def.isOrthographicCamera;\nconst isBox3 = def => def && def.isBox3;\nconst context = /* @__PURE__ */React.createContext(null);\nfunction Bounds({\n  children,\n  damping = 6,\n  fit,\n  clip,\n  observe,\n  margin = 1.2,\n  eps = 0.01,\n  onFit\n}) {\n  const ref = React.useRef(null);\n  const {\n    camera,\n    invalidate,\n    size,\n    controls: controlsImpl\n  } = useThree();\n  const controls = controlsImpl;\n  const onFitRef = React.useRef(onFit);\n  onFitRef.current = onFit;\n  function equals(a, b) {\n    return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps && Math.abs(a.z - b.z) < eps;\n  }\n  function damp(v, t, lambda, delta) {\n    v.x = THREE.MathUtils.damp(v.x, t.x, lambda, delta);\n    v.y = THREE.MathUtils.damp(v.y, t.y, lambda, delta);\n    v.z = THREE.MathUtils.damp(v.z, t.z, lambda, delta);\n  }\n  const [current] = React.useState(() => ({\n    animating: false,\n    focus: new THREE.Vector3(),\n    camera: new THREE.Vector3(),\n    zoom: 1\n  }));\n  const [goal] = React.useState(() => ({\n    focus: new THREE.Vector3(),\n    camera: new THREE.Vector3(),\n    zoom: 1\n  }));\n  const [box] = React.useState(() => new THREE.Box3());\n  const api = React.useMemo(() => {\n    function getSize() {\n      const size = box.getSize(new THREE.Vector3());\n      const center = box.getCenter(new THREE.Vector3());\n      const maxSize = Math.max(size.x, size.y, size.z);\n      const fitHeightDistance = isOrthographic(camera) ? maxSize * 4 : maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));\n      const fitWidthDistance = isOrthographic(camera) ? maxSize * 4 : fitHeightDistance / camera.aspect;\n      const distance = margin * Math.max(fitHeightDistance, fitWidthDistance);\n      return {\n        box,\n        size,\n        center,\n        distance\n      };\n    }\n    return {\n      getSize,\n      refresh(object) {\n        if (isBox3(object)) box.copy(object);else {\n          const target = object || ref.current;\n          if (!target) return this;\n          target.updateWorldMatrix(true, true);\n          box.setFromObject(target);\n        }\n        if (box.isEmpty()) {\n          const max = camera.position.length() || 10;\n          box.setFromCenterAndSize(new THREE.Vector3(), new THREE.Vector3(max, max, max));\n        }\n        if ((controls == null ? void 0 : controls.constructor.name) === 'OrthographicTrackballControls') {\n          // Put camera on a sphere along which it should move\n          const {\n            distance\n          } = getSize();\n          const direction = camera.position.clone().sub(controls.target).normalize().multiplyScalar(distance);\n          const newPos = controls.target.clone().add(direction);\n          camera.position.copy(newPos);\n        }\n        return this;\n      },\n      clip() {\n        const {\n          distance\n        } = getSize();\n        if (controls) controls.maxDistance = distance * 10;\n        camera.near = distance / 100;\n        camera.far = distance * 100;\n        camera.updateProjectionMatrix();\n        if (controls) controls.update();\n        invalidate();\n        return this;\n      },\n      to({\n        position,\n        target\n      }) {\n        current.camera.copy(camera.position);\n        const {\n          center\n        } = getSize();\n        goal.camera.set(...position);\n        if (target) {\n          goal.focus.set(...target);\n        } else {\n          goal.focus.copy(center);\n        }\n        if (damping) {\n          current.animating = true;\n        } else {\n          camera.position.set(...position);\n        }\n        return this;\n      },\n      fit() {\n        current.camera.copy(camera.position);\n        if (controls) current.focus.copy(controls.target);\n        const {\n          center,\n          distance\n        } = getSize();\n        const direction = center.clone().sub(camera.position).normalize().multiplyScalar(distance);\n        goal.camera.copy(center).sub(direction);\n        goal.focus.copy(center);\n        if (isOrthographic(camera)) {\n          current.zoom = camera.zoom;\n          let maxHeight = 0,\n            maxWidth = 0;\n          const vertices = [new THREE.Vector3(box.min.x, box.min.y, box.min.z), new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(box.min.x, box.min.y, box.max.z), new THREE.Vector3(box.min.x, box.max.y, box.max.z), new THREE.Vector3(box.max.x, box.max.y, box.max.z), new THREE.Vector3(box.max.x, box.max.y, box.min.z), new THREE.Vector3(box.max.x, box.min.y, box.max.z), new THREE.Vector3(box.max.x, box.min.y, box.min.z)];\n          // Transform the center and each corner to camera space\n          center.applyMatrix4(camera.matrixWorldInverse);\n          for (const v of vertices) {\n            v.applyMatrix4(camera.matrixWorldInverse);\n            maxHeight = Math.max(maxHeight, Math.abs(v.y - center.y));\n            maxWidth = Math.max(maxWidth, Math.abs(v.x - center.x));\n          }\n          maxHeight *= 2;\n          maxWidth *= 2;\n          const zoomForHeight = (camera.top - camera.bottom) / maxHeight;\n          const zoomForWidth = (camera.right - camera.left) / maxWidth;\n          goal.zoom = Math.min(zoomForHeight, zoomForWidth) / margin;\n          if (!damping) {\n            camera.zoom = goal.zoom;\n            camera.updateProjectionMatrix();\n          }\n        }\n        if (damping) {\n          current.animating = true;\n        } else {\n          camera.position.copy(goal.camera);\n          camera.lookAt(goal.focus);\n          if (controls) {\n            controls.target.copy(goal.focus);\n            controls.update();\n          }\n        }\n        if (onFitRef.current) onFitRef.current(this.getSize());\n        invalidate();\n        return this;\n      }\n    };\n  }, [box, camera, controls, margin, damping, invalidate]);\n  React.useLayoutEffect(() => {\n    if (controls) {\n      // Try to prevent drag hijacking\n      const callback = () => current.animating = false;\n      controls.addEventListener('start', callback);\n      return () => controls.removeEventListener('start', callback);\n    }\n  }, [controls]);\n\n  // Scale pointer on window resize\n  const count = React.useRef(0);\n  React.useLayoutEffect(() => {\n    if (observe || count.current++ === 0) {\n      api.refresh();\n      if (fit) api.fit();\n      if (clip) api.clip();\n    }\n  }, [size, clip, fit, observe, camera, controls]);\n  useFrame((state, delta) => {\n    if (current.animating) {\n      damp(current.focus, goal.focus, damping, delta);\n      damp(current.camera, goal.camera, damping, delta);\n      current.zoom = THREE.MathUtils.damp(current.zoom, goal.zoom, damping, delta);\n      camera.position.copy(current.camera);\n      if (isOrthographic(camera)) {\n        camera.zoom = current.zoom;\n        camera.updateProjectionMatrix();\n      }\n      if (!controls) {\n        camera.lookAt(current.focus);\n      } else {\n        controls.target.copy(current.focus);\n        controls.update();\n      }\n      invalidate();\n      if (isOrthographic(camera) && !(Math.abs(current.zoom - goal.zoom) < eps)) return;\n      if (!isOrthographic(camera) && !equals(current.camera, goal.camera)) return;\n      if (controls && !equals(current.focus, goal.focus)) return;\n      current.animating = false;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: ref\n  }, /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children));\n}\nfunction useBounds() {\n  return React.useContext(context);\n}\n\nexport { Bounds, useBounds };\n"],"names":["isOrthographic","def","isBox3","context","React.createContext","Bounds","children","damping","fit","clip","observe","margin","eps","onFit","ref","React.useRef","camera","invalidate","size","controlsImpl","useThree","controls","onFitRef","equals","a","b","damp","v","t","lambda","delta","THREE.MathUtils","current","React.useState","THREE.Vector3","goal","box","THREE.Box3","api","React.useMemo","getSize","center","maxSize","fitHeightDistance","fitWidthDistance","distance","object","target","max","direction","newPos","position","maxHeight","maxWidth","vertices","zoomForHeight","zoomForWidth","React.useLayoutEffect","callback","count","useFrame","state","React.createElement","useBounds","React.useContext"],"mappings":"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","x_google_ignoreList":[0]}