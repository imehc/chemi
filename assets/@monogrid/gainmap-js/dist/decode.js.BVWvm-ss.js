import{Q as k}from"./QuadRenderer-6HrRQdJM.js.CODTGMJp.js";import{h as H,i as $,j as J,T as L,H as Q,b as S,U as B,C as D,L as T,k as E,R as O,f as R,l as X,c as z,V as b,N as Y}from"../../../three/build/three.module.js.CElijN_X.js";const j=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,K=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class Z extends z{constructor({gamma:e,offsetHdr:r,offsetSdr:a,gainMapMin:d,gainMapMax:t,maxDisplayBoost:o,hdrCapacityMin:n,hdrCapacityMax:g,sdr:l,gainMap:m}){super({name:"GainMapDecoderMaterial",vertexShader:j,fragmentShader:K,uniforms:{sdr:{value:l},gainMap:{value:m},gamma:{value:new b(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new b().fromArray(r)},offsetSdr:{value:new b().fromArray(a)},gainMapMin:{value:new b().fromArray(d)},gainMapMax:{value:new b().fromArray(t)},weightFactor:{value:(Math.log2(o)-n)/(g-n)}},blending:Y,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=o,this._hdrCapacityMin=n,this._hdrCapacityMax=g,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const r=this.uniforms.gamma.value;r.x=1/e[0],r.y=1/e[1],r.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class N extends Error{}class G extends Error{}const A=(c,e,r)=>{var a;let d;const t=(a=c.attributes.getNamedItem(e))===null||a===void 0?void 0:a.nodeValue;if(t)d=t;else{const o=c.getElementsByTagName(e)[0];if(o){const n=o.getElementsByTagName("rdf:li");if(n.length===3)d=Array.from(n).map(g=>g.innerHTML);else throw new Error(`Gainmap metadata contains an array of items for ${e} but its length is not 3`)}else{if(r)return r;throw new Error(`Can't find ${e} in gainmap metadata`)}}return d},q=c=>{var e,r;let a;typeof TextDecoder<"u"?a=new TextDecoder().decode(c):a=c.toString();let d=a.indexOf("<x:xmpmeta");const t=new DOMParser;for(;d!==-1;){const o=a.indexOf("x:xmpmeta>",d);a.slice(d,o+10);const n=a.slice(d,o+10);try{const l=t.parseFromString(n,"text/xml").getElementsByTagName("rdf:Description")[0],m=A(l,"hdrgm:GainMapMin","0"),f=A(l,"hdrgm:GainMapMax"),i=A(l,"hdrgm:Gamma","1"),y=A(l,"hdrgm:OffsetSDR","0.015625"),M=A(l,"hdrgm:OffsetHDR","0.015625");let x=(e=l.attributes.getNamedItem("hdrgm:HDRCapacityMin"))===null||e===void 0?void 0:e.nodeValue;x||(x="0");const v=(r=l.attributes.getNamedItem("hdrgm:HDRCapacityMax"))===null||r===void 0?void 0:r.nodeValue;if(!v)throw new Error("Incomplete gainmap metadata");return{gainMapMin:Array.isArray(m)?m.map(u=>parseFloat(u)):[parseFloat(m),parseFloat(m),parseFloat(m)],gainMapMax:Array.isArray(f)?f.map(u=>parseFloat(u)):[parseFloat(f),parseFloat(f),parseFloat(f)],gamma:Array.isArray(i)?i.map(u=>parseFloat(u)):[parseFloat(i),parseFloat(i),parseFloat(i)],offsetSdr:Array.isArray(y)?y.map(u=>parseFloat(u)):[parseFloat(y),parseFloat(y),parseFloat(y)],offsetHdr:Array.isArray(M)?M.map(u=>parseFloat(u)):[parseFloat(M),parseFloat(M),parseFloat(M)],hdrCapacityMin:parseFloat(x),hdrCapacityMax:parseFloat(v)}}catch{}d=a.indexOf("<x:xmpmeta",o)}};class ee{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((r,a)=>{const d=this.options.debug,t=new DataView(e.buffer);if(t.getUint16(0)!==65496){a(new Error("Not a valid jpeg"));return}const o=t.byteLength;let n=2,g=0,l;for(;n<o;){if(++g>250){a(new Error(`Found no marker after ${g} loops ðŸ˜µ`));return}if(t.getUint8(n)!==255){a(new Error(`Not a valid marker at offset 0x${n.toString(16)}, found: 0x${t.getUint8(n).toString(16)}`));return}if(l=t.getUint8(n+1),d&&console.log(`Marker: ${l.toString(16)}`),l===226){d&&console.log("Found APP2 marker (0xffe2)");const m=n+4;if(t.getUint32(m)===1297106432){const f=m+4;let i;if(t.getUint16(f)===18761)i=!1;else if(t.getUint16(f)===19789)i=!0;else{a(new Error("No valid endianness marker found in TIFF header"));return}if(t.getUint16(f+2,!i)!==42){a(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const y=t.getUint32(f+4,!i);if(y<8){a(new Error("Not valid TIFF data! (First offset less than 8)"));return}const M=f+y,x=t.getUint16(M,!i),v=M+2;let u=0;for(let h=v;h<v+12*x;h+=12)t.getUint16(h,!i)===45057&&(u=t.getUint32(h+8,!i));const C=M+2+x*12+4,F=[];for(let h=C;h<C+u*16;h+=16){const p={MPType:t.getUint32(h,!i),size:t.getUint32(h+4,!i),dataOffset:t.getUint32(h+8,!i),dependantImages:t.getUint32(h+12,!i),start:-1,end:-1,isFII:!1};p.dataOffset?(p.start=f+p.dataOffset,p.isFII=!1):(p.start=0,p.isFII=!0),p.end=p.start+p.size,F.push(p)}if(this.options.extractNonFII&&F.length){const h=new Blob([t]),p=[];for(const w of F){if(w.isFII&&!this.options.extractFII)continue;const I=h.slice(w.start,w.end+1,"image/jpeg");p.push(I)}r(p)}}}n+=2+t.getUint16(n+2)}})}}const te=async c=>{const e=q(c);if(!e)throw new G("Gain map XMP metadata not found");const a=await new ee({extractFII:!0,extractNonFII:!0}).extract(c);if(a.length!==2)throw new N("Gain map recovery image not found");return{sdr:new Uint8Array(await a[0].arrayBuffer()),gainMap:new Uint8Array(await a[1].arrayBuffer()),metadata:e}},P=c=>new Promise((e,r)=>{const a=document.createElement("img");a.onload=()=>{e(a)},a.onerror=d=>{r(d)},a.src=URL.createObjectURL(c)});class U extends ${constructor(e,r){super(r),e&&(this._renderer=e),this._internalLoadingManager=new J}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new Z({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new L,sdr:new L});return new k({width:16,height:16,type:Q,colorSpace:S,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,r,a,d){const t=d?new Blob([d],{type:"image/jpeg"}):void 0,o=new Blob([a],{type:"image/jpeg"});let n,g,l=!1;if(typeof createImageBitmap>"u"){const i=await Promise.all([t?P(t):Promise.resolve(void 0),P(o)]);g=i[0],n=i[1],l=!0}else{const i=await Promise.all([t?createImageBitmap(t,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(o,{imageOrientation:"flipY"})]);g=i[0],n=i[1]}const m=new L(g||new ImageData(2,2),B,D,D,T,E,O,R,1,S);m.flipY=l,m.needsUpdate=!0;const f=new L(n,B,D,D,T,E,O,R,1,X);f.flipY=l,f.needsUpdate=!0,e.width=n.width,e.height=n.height,e.material.gainMap=m,e.material.sdr=f,e.material.gainMapMin=r.gainMapMin,e.material.gainMapMax=r.gainMapMax,e.material.offsetHdr=r.offsetHdr,e.material.offsetSdr=r.offsetSdr,e.material.gamma=r.gamma,e.material.hdrCapacityMin=r.hdrCapacityMin,e.material.hdrCapacityMax=r.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,r.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class ie extends U{load([e,r,a],d,t,o){const n=this.prepareQuadRenderer();let g,l,m;const f=async()=>{if(g&&l&&m){try{await this.render(n,m,g,l)}catch(s){this.manager.itemError(e),this.manager.itemError(r),this.manager.itemError(a),typeof o=="function"&&o(s),n.disposeOnDemandRenderer();return}typeof d=="function"&&d(n),this.manager.itemEnd(e),this.manager.itemEnd(r),this.manager.itemEnd(a),n.disposeOnDemandRenderer()}};let i=!0,y=0,M=0,x=!0,v=0,u=0,_=!0,C=0,F=0;const h=()=>{if(typeof t=="function"){const s=y+v+C,W=M+u+F,V=i&&x&&_;t(new ProgressEvent("progress",{lengthComputable:V,loaded:W,total:s}))}};this.manager.itemStart(e),this.manager.itemStart(r),this.manager.itemStart(a);const p=new H(this._internalLoadingManager);p.setResponseType("arraybuffer"),p.setRequestHeader(this.requestHeader),p.setPath(this.path),p.setWithCredentials(this.withCredentials),p.load(e,async s=>{if(typeof s=="string")throw new Error("Invalid sdr buffer");g=s,await f()},s=>{i=s.lengthComputable,M=s.loaded,y=s.total,h()},s=>{this.manager.itemError(e),typeof o=="function"&&o(s)});const w=new H(this._internalLoadingManager);w.setResponseType("arraybuffer"),w.setRequestHeader(this.requestHeader),w.setPath(this.path),w.setWithCredentials(this.withCredentials),w.load(r,async s=>{if(typeof s=="string")throw new Error("Invalid gainmap buffer");l=s,await f()},s=>{x=s.lengthComputable,u=s.loaded,v=s.total,h()},s=>{this.manager.itemError(r),typeof o=="function"&&o(s)});const I=new H(this._internalLoadingManager);return I.setRequestHeader(this.requestHeader),I.setPath(this.path),I.setWithCredentials(this.withCredentials),I.load(a,async s=>{if(typeof s!="string")throw new Error("Invalid metadata string");m=JSON.parse(s),await f()},s=>{_=s.lengthComputable,F=s.loaded,C=s.total,h()},s=>{this.manager.itemError(a),typeof o=="function"&&o(s)}),n}}class ne extends U{load(e,r,a,d){const t=this.prepareQuadRenderer(),o=new H(this._internalLoadingManager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(this.withCredentials),this.manager.itemStart(e),o.load(e,async n=>{if(typeof n=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const g=new Uint8Array(n);let l,m,f;try{const i=await te(g);l=i.sdr,m=i.gainMap,f=i.metadata}catch(i){if(i instanceof G||i instanceof N)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),f={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},l=g;else throw i}try{await this.render(t,f,l,m)}catch(i){this.manager.itemError(e),typeof d=="function"&&d(i),t.disposeOnDemandRenderer();return}typeof r=="function"&&r(t),this.manager.itemEnd(e),t.disposeOnDemandRenderer()},a,n=>{this.manager.itemError(e),typeof d=="function"&&d(n)}),t}}export{ie as G,ne as H};
